# 从一首完整的钢琴曲里提取主旋律以及所有和弦的算法

最近在写一些musicpy的功能的时候，遇到了需要把一首曲子的主旋律和和弦部分分离出来的需求。有个功能是对曲子进行智能作曲分析。比如现在我们读取了一个MIDI文件，这是一首钢琴曲，主旋律和和弦部分全部都是放在一个轨道的。这首钢琴曲总共有1400个音符，包括主旋律和和弦部分。现在我们想要对这1400个音符进行调性分析，（暂时不考虑曲子的转调和离调）判断这首曲子是在什么调。

除了分析调性之外，还需要对一首曲子的和弦走向进行分析，因此和弦部分也需要单独提取出来。可能有人会觉得，提取一首曲子的主旋律不就是把最高的那部分音抓下来吗，不过其实还真的没有这么简单。

首先，在MIDI文件读取出来后，音符的先后顺序取决于每个音符出现的时间（读到这个音符的note_on信息）。musicpy里的和弦类的数据结构设计是把音符存放在一个列表里，然后每两个相邻音符之间的间隔存放在另一个列表里，每个音符自己有个参数duration，记录着这个音符的持续长度。音符在列表里的先后顺序也是和MIDI文件里的信息是一样的，哪个音符先出现开始演奏的信息就在列表里先出现。

这首钢琴曲里的主旋律与和弦部分是放在一起的，难点在于，很多和弦音，尤其是分解和弦的最高音可能很高，弹到只比当前的主旋律低一点点。这些弹到主旋律范围内的和弦音是为了给主旋律进行和声装饰以及丰富曲子的层次感与律动感。但是我们人耳在听的时候，还是能分辨出那些弹到主旋律的和弦音，因为这些音并没有和主旋律一样形成“连贯的旋律感”，所以一般情况下不会被听众归类为主旋律。（不过也不是完全没有例外，偶尔有时候有些钢琴曲就是把一部分主旋律同时也当做当前的和弦的最高音的）

这首钢琴曲的音域跨度很大，主旋律的音域横跨三个八度左右，和弦部分也横跨三个八度左右，因此找一个单独的音作为分界线来划分主旋律与和弦部分很明显是不现实的。

现在来说说我的算法。

1. 首先，把所有音符里间隔为0的音符组找出来，（也就是同时一起弹的音符）然后只保留最高的音。因为如果是一个主旋律，下面同时弹了一些音，那么这些音一般来说就是和弦音或者是丰富和声用的装饰音。
2. 接下来，开始一个循环，遍历整个音符列表。这里需要提到我这个算法里的两个原创概念：旋律归类容许阈值（melody tolerance），和弦归类容许阈值（chord tolerance），这两个值经过多次测试之后，默认值为小七度（minor seventh）和大六度（major sixth）。首先，对于第一个音符，如果第二个音符比第一个音符的音高差要大于或等于和弦归类容许阈值，则第一个音符被判定为和弦音，第二个音符为第一个被判定为旋律的音符，否则就是第二个音符为和弦音符，第一个音符为主旋律音符。
3. 现在我们已经有了第一个主旋律音符。在遍历整个音符列表的过程中，计算最近一个小节的长度之内（8个单位音符长度）被归类为旋律的音符的平均音高，如果当前被归类为旋律的音符总长度还不满一个小节，则计算所有当前被归类为音符的平均音高。如果当前音符的音高要高于这个平均音高，则被判定为主旋律音符。如果比平均音高低，但是音高差要小于或等于旋律归类容许阈值，则当前的音符很有可能是主旋律音符。
4. 在这个条件成立的基础上，如果最近的一个被判定为主旋律的音符与当前音符的音高差小于和弦归类容许阈值，则当前的音符被判定为主旋律音符。（因为如果最近的主旋律的音符需要突然跳很远下来到当前音符，那么即使作曲者本意是想把当前音符也当做主旋律，听众也很难形成旋律上的连贯感，因为旋律本质上就是一组音高比较相近的音符，与音高差距大的和弦音形成对比而被当做旋律的。）如果当前音符比平均音高低，而且音高差超过旋律归类容许阈值，当且仅当最近的一个主旋律音符与当前音符的音高差和下一个音符与当前音符的音高差都小于和弦容许归类阈值，当前的音符被判定为主旋律音符。

我用这个自己想的主旋律分离算法给自己的很多音乐作品进行了测试，效果出奇的好，可以几乎100%地提取出完整的正确的主旋律音，无论主旋律的音域跨度有多大。主旋律提纯算法成功了之后，和弦提取就很简单了，其实也就是主旋律都找出来后，剩下的音就是和弦音或者主旋律装饰和声了。

在musicpy里我把这个原创的分离一首曲子的主旋律与和弦音的算法写成了一个函数，叫做`split_melody`，可以把一个和弦类型的曲子分离出主旋律作为新的和弦类型。还有`split_chord`函数可以分离出和弦音作为新的和弦类型，`split_all`函数会返回2个和弦类型，分别是曲子的主旋律与和弦音。

`split_melody`函数的参数按照顺序为：

```python
split_melody(current_chord,
             mode='chord',
             melody_tol=database.minor_seventh,
             chord_tol=database.major_sixth,
             get_off_overlap_notes=True,
             get_off_same_time=True,
             average_degree_length=8,
             melody_degree_tol='B4')
```

- current_chord: 想要进行分离主旋律与和弦音的和弦类型（一个和弦类型本身可以储存一个单乐器的完整的曲子，比如钢琴曲）

- mode: 分离主旋律后返回的具体内容的表达形式，mode='index'返回的是所有的主旋律音符在x中的位置（第几个音），mode='notes'返回的是所有的主旋律音符的列表，mode='chord'返回的是所有的主旋律音符组成的新的和弦类型，其音符间隔都会经过重新计算，以达到和实际上把和弦音去掉之后剩下的音符的间隔一样。

- melody_tol: 这个参数就是上面我在描述我的算法的时候说的旋律归类容许阈值（melody tolerance），可以自己设定音程大小，默认值为minor_seventh（小七度）。

- chord_tol: 这个参数就是上面我在描述我的算法的时候说的和弦归类容许阈值（chord tolerance），可以自己设定音程大小，默认值为major_sixth（大六度）。

- get_off_overlap_notes: 这个参数是为了应对有些MIDI文件音符大量重叠（同音重叠）可能造成算法无法达到预期效果的情况，设置为True的时候会检测MIDI文件中有无重叠音符的情况，并且把重叠的音符全部去重。

- get_off_same_time: 如果设置为True，对于每一组同时开始的音符，只保留音高最高的那一个。

- average_degree_length: 算法中的每过几个小节计算当前平均的音高。默认值为8小节。

- melody_degree_tol: 这个是最近我改进了这个算法之后新加入的第3个容许阈值，叫做旋律音级归类容许阈值（melody degree tolerance），主要用来判断和弦音有来回转折的情况，比如阿尔贝蒂低音这种情况，可以让主旋律与和弦音更加灵活地分离，能够更加提高分离主旋律与和弦音的纯度。默认值为B4这个音。

接下来我把具体的操作描述一下。

首先我们把曲子准备好，可以是任意的MIDI文件，然后使用`read`函数读取你想要分离的音轨。比如

```python
a, bpm, start_time = read('example.mid').merge()
```

`read`函数返回的是一个乐曲类型，使用`merge`函数可以得到1个有着3个元素的tuple，分别为曲子的和弦类型，曲子的速度(BPM)，曲子开始的时间(单位为小节)

然后我们可以使用

```python
example_melody = a.split_melody(mode='chord')
```

得到example这首曲子的主旋律组成的新的和弦类型，然后我们可以使用`play`函数或者`write`函数把主旋律写进新的MIDI文件，(`play`函数的name可以不写，输出的MIDI文件的名字默认为temp.mid)

```python
play(melody, bpm, name='example melody.mid')
```

或者

```python
write(melody, bpm, name='example melody.mid')
```

然后example的主旋律的MIDI文件就会生成在musicpy文件夹里了，大家可以拿去编曲宿主或者其他需要的场合使用。

使用`split_chord`函数可以提取一首曲子的和弦音，其实就是做和`split_melody`互补的事情，具体操作和上面的差不多，只是输出的MIDI文件变成了一首曲子的和弦音，比如叫做`example_chords`。

使用`split_all`函数可以同时得到一首曲子的主旋律与和弦音的2个和弦类型，大家都可以用一样的方法分别输出为新的MIDI文件。主旋律与和弦音的开始时间都存储在结果里，所以当你对主旋律或者和弦音作出修改之后，想要重新合并为一首新的曲子，你可以写

```python
example_melody & example_chords
```

来得到跟之前的曲子开始位置一样的新的曲子。

请注意：`split_all`函数返回的主旋律与和弦音的2个和弦类型的音符列表都含有和分离前的曲子相同的pitch_bend和tempo类型，因为非音符类型不参与分离算法，但是会在分离结果中进行保留。因此当你合并主旋律与和弦音的时候，请清除其中一个和弦类型的pitch_bend和tempo类型再进行合并，以避免pitch_bend和tempo类型重复出现，推荐使用和弦类型自带的`only_notes`函数直接获得一个只含有音符类型的和弦类型。比如:

```python
example_melody & example_chords.only_notes()
```

主旋律与和弦音保留的pitch_bend和tempo类型的开始时间都是相对于原曲的，因此在主旋律或者和弦音不是从原曲最开始出现的情况下，pitch_bend和tempo类型的开始时间在主旋律或者和弦音单独播放的时候可能会有偏差。

如果想要获得准确的pitch_bend和tempo类型相对于主旋律或者和弦音的开始时间，可以使用和弦类型的`apply_start_time_to_changes`函数来将主旋律与和弦音的开始时间应用于它们之内的pitch_bend和tempo类型 (如果要合并为原曲就不需要应用开始时间)，比如:

```python
example_melody_individual = copy(example_melody)
example_chords_individual = copy(example_chords)
example_chords_individual.apply_start_time_to_changes(example_chords.start_time)
example_melody_individual.apply_start_time_to_changes(example_melody.start_time)
```

对于不同的曲子，设置不同的3个容许阈值可能会让效果更好，默认的3个容许阈值可以适用于大部分流行或者爵士钢琴曲。

在我写的一个智能钢琴软件Ideal Piano中，我也有把这个算法作为其中一项特色的功能，大家选择MIDI文件之后可以选择分离主旋律，只听和弦音。

